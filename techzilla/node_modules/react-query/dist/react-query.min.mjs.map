{"version":3,"file":"react-query.min.mjs","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils.js","../src/config.js","../src/queryCache.js","../src/setFocusHandler.js","../src/useIsFetching.js","../src/useMutation.js","../src/useBaseQuery.js","../src/useQuery.js","../src/usePaginatedQuery.js","../src/useInfiniteQuery.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, variables = [], queryFn, config = {} } = args[0]\n      return [queryKey, variables, queryFn, config]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  if (typeof args[2] === 'function') {\n    const [queryKey, variables = [], queryFn, config = {}] = args\n    return [queryKey, variables, queryFn, config]\n  }\n\n  const [queryKey, queryFn, config = {}] = args\n\n  return [queryKey, [], queryFn, config]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {\n    if (queryInfo.status === statusError) {\n      setTimeout(() => {\n        queryInfo.query.state.status = 'loading'\n      })\n      throw queryInfo.error\n    }\n  }\n\n  if (queryInfo.config.suspense) {\n    if (queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.refetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  retry: 3,\n  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n  queryKeySerializerFn: defaultQueryKeySerializerFn,\n  queryFnParamsFilter: identity,\n  throwOnError: false,\n  useErrorBoundary: undefined, // this will default to the suspense value\n  onMutate: noop,\n  onSuccess: noop,\n  onError: noop,\n  onSettled: noop,\n  refetchOnMount: true,\n  isDataEqual: deepEqual,\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo(() => {\n    const newConfig = {\n      ...(configContextValue || defaultConfigRef.current),\n      ...config,\n    }\n\n    // Default useErrorBoundary to the suspense value\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense\n    }\n\n    return newConfig\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n\n      // Default useErrorBoundary to the suspense value\n      if (typeof defaultConfigRef.current.useErrorBoundary === 'undefined') {\n        defaultConfigRef.current.useErrorBoundary =\n          defaultConfigRef.current.suspense\n      }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey())\n    } catch {\n      return []\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey]\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport function useQueryCache() {\n  return React.useContext(queryCacheContext)\n}\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const cache = React.useMemo(() => queryCache || makeQueryCache(), [\n    queryCache,\n  ])\n\n  React.useEffect(() => {\n    queryCaches.push(cache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(cache)\n      if (i >= 0) {\n        queryCaches.splice(i, 1)\n      }\n      // if the cache was created by us, we need to tear it down\n      if (queryCache == null) {\n        cache.clear()\n      }\n    }\n  }, [cache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={cache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = {}\nconst actionFailed = {}\nconst actionMarkStale = {}\nconst actionMarkGC = {}\nconst actionFetch = {}\nconst actionSuccess = {}\nconst actionError = {}\nconst actionSetState = {}\n\nexport function makeQueryCache() {\n  const listeners = []\n\n  const cache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    cache.isFetching = Object.values(cache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n    listeners.forEach(d => d(cache))\n  }\n\n  cache.subscribe = cb => {\n    listeners.push(cb)\n    return () => {\n      listeners.splice(listeners.indexOf(cb), 1)\n    }\n  }\n\n  cache.clear = () => {\n    Object.values(cache.queries).forEach(query => query.clear())\n    cache.queries = {}\n    notifyGlobalListeners()\n  }\n\n  const findQueries = (predicate, { exact } = {}) => {\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = defaultConfigRef.current.queryKeySerializerFn(predicate)\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(cache.queries).filter(predicate)\n  }\n\n  cache.getQueries = findQueries\n\n  cache.getQuery = queryKey => findQueries(queryKey, { exact: true })[0]\n\n  cache.getQueryData = queryKey => cache.getQuery(queryKey)?.state.data\n\n  cache.removeQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      clearTimeout(query.staleTimeout)\n      delete cache.queries[query.queryHash]\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.cancelQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      query.cancel()\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.refetchQueries = async (\n    predicate,\n    { exact, throwOnError, force } = {}\n  ) => {\n    const foundQueries =\n      predicate === true\n        ? Object.values(cache.queries)\n        : findQueries(predicate, { exact })\n\n    try {\n      return await Promise.all(\n        foundQueries.map(query => query.fetch({ force }))\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  cache._buildQuery = (userQueryKey, queryVariables, queryFn, config) => {\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = cache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryVariables, queryFn })\n      query.config = { ...query.config, ...config }\n    } else {\n      query = makeQuery({\n        cache,\n        queryKey,\n        queryHash,\n        queryVariables,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    return query\n  }\n\n  cache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryVariables,\n      queryFn,\n      { force, ...config },\n    ] = getQueryArgs(args)\n\n    config = {\n      ...defaultConfigRef.current,\n      ...config,\n    }\n\n    const query = cache._buildQuery(queryKey, queryVariables, queryFn, config)\n\n    // Don't prefetch queries that are fresh, unless force is passed\n    if (query.state.isStale || force) {\n      // Trigger a fetch and return the promise\n      try {\n        const res = await query.fetch({ force })\n        query.wasPrefetched = true\n        return res\n      } catch (err) {\n        if (config.throwOnError) {\n          throw err\n        }\n      }\n    }\n\n    return query.state.data\n  }\n\n  cache.setQueryData = (queryKey, updater, { exact, ...config } = {}) => {\n    let queries = findQueries(queryKey, { exact })\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [\n        cache._buildQuery(queryKey, undefined, () => new Promise(noop), {\n          ...defaultConfigRef.current,\n          ...config,\n        }),\n      ]\n    }\n\n    queries.forEach(d => d.setData(updater))\n  }\n\n  function makeQuery(options) {\n    const queryCache = options.cache\n    const reducer = options.config.queryReducer || defaultQueryReducer\n\n    const noQueryHash = typeof options.queryHash === 'undefined'\n\n    const initialData =\n      typeof options.config.initialData === 'function'\n        ? options.config.initialData()\n        : options.config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = noQueryHash ? true : !hasInitialData\n\n    const manual = options.config.manual\n\n    const initialStatus =\n      noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading\n\n    const query = {\n      ...options,\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n        manual,\n      }),\n    }\n\n    const dispatch = action => {\n      query.state = reducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({ type: actionMarkStale })\n        }\n      }, query.config.staleTime)\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          cache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n\n      notifyGlobalListeners()\n    }\n\n    query.updateInstance = instance => {\n      let found = query.instances.find(d => d.id === instance.id)\n\n      if (found) {\n        Object.assign(found, instance)\n      } else {\n        found = {\n          onStateUpdate: noop,\n          ...instance,\n        }\n        query.instances.push(instance)\n      }\n    }\n\n    query.subscribe = instanceId => {\n      query.heal()\n\n      // Return the unsubscribe function\n      return () => {\n        query.instances = query.instances.filter(d => d.id !== instanceId)\n\n        if (!query.instances.length) {\n          query.cancel()\n\n          // Schedule garbage collection\n          query.scheduleGarbageCollection()\n        }\n      }\n    }\n\n    // Set up the fetch function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue fetch retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ force, __queryFn = query.queryFn } = {}) => {\n      // Don't refetch fresh queries that don't have a queryHash\n\n      if (!query.queryHash || (!query.state.isStale && !force)) {\n        return\n      }\n\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.suspenseInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            dispatch({ type: actionFetch })\n\n            // Try to fetch\n            let data = await tryFetchData(\n              __queryFn,\n              ...query.queryKey,\n              ...query.queryVariables\n            )\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSuccess && instance.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSettled && instance.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance => instance.onError && instance.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.onSettled && instance.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    query.setState = updater => dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      clearTimeout(query.staleTimeout)\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      query.cancel()\n    }\n\n    return query\n  }\n\n  return cache\n}\n\nexport function defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching:\n          action.hasInitialData || action.manual\n            ? false\n            : action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { defaultConfigRef } from './config'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  const { refetchAllOnWindowFocus } = defaultConfigRef.current\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .refetchQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (query.config.manual === true) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so `fetch` will create new one\n            delete query.promise\n            return true\n          }\n\n          if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n            return refetchAllOnWindowFocus\n          } else {\n            return query.config.refetchOnWindowFocus\n          }\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, setState] = React.useState({})\n\n  React.useEffect(() => {\n    return queryCache.subscribe(() => setState({}))\n  }, [])\n\n  return React.useMemo(() => state && queryCache.isFetching, [state])\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext(),\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport {\n  useUid,\n  isDocumentVisible,\n  Console,\n  useGetLatest,\n  useMountedCallback,\n} from './utils'\n\nexport function useBaseQuery(queryKey, queryVariables, queryFn, config = {}) {\n  const instanceId = useUid()\n\n  config = {\n    ...useConfigContext(),\n    ...config,\n  }\n\n  const queryCache = useQueryCache()\n\n  const queryRef = React.useRef()\n\n  const newQuery = queryCache._buildQuery(\n    queryKey,\n    queryVariables,\n    queryFn,\n    config\n  )\n\n  const useCachedQuery =\n    queryRef.current &&\n    typeof queryRef.current.queryHash === 'undefined' &&\n    typeof newQuery.queryHash === 'undefined'\n\n  // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n  if (!useCachedQuery) {\n    queryRef.current = newQuery\n  }\n\n  const query = queryRef.current\n\n  const [, unsafeRerender] = React.useState()\n\n  const rerender = useMountedCallback(unsafeRerender)\n\n  const getLatestConfig = useGetLatest(config)\n  const refetch = React.useCallback(\n    async ({ throwOnError, ...rest } = {}) => {\n      try {\n        return await query.fetch(rest)\n      } catch (err) {\n        if (throwOnError) {\n          throw err\n        }\n      }\n    },\n    [query]\n  )\n\n  query.suspenseInstance = {\n    onSuccess: data => getLatestConfig().onSuccess(data),\n    onError: err => getLatestConfig().onError(err),\n    onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n  }\n\n  // After mount, subscribe to the query\n  React.useEffect(() => {\n    // Update the instance to the query again, but not as a placeholder\n    query.updateInstance({\n      id: instanceId,\n      onStateUpdate: () => rerender({}),\n      onSuccess: data => getLatestConfig().onSuccess(data),\n      onError: err => getLatestConfig().onError(err),\n      onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n    })\n\n    return query.subscribe(instanceId)\n  }, [getLatestConfig, instanceId, query, rerender])\n\n  React.useEffect(() => {\n    // Perform the initial fetch for this query if necessary\n    if (\n      !getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n      !query.wasPrefetched && // Don't double fetch for prefetched queries\n      !query.wasSuspended && // Don't double fetch for suspense\n      query.state.isStale && // Only refetch if stale\n      (getLatestConfig().refetchOnMount || query.instances.length === 1)\n    ) {\n      refetch().catch(Console.error)\n    }\n\n    query.wasPrefetched = false\n    query.wasSuspended = false\n  }, [getLatestConfig, query, refetch])\n\n  // Handle refetch interval\n  React.useEffect(() => {\n    const query = queryRef.current\n    if (\n      config.refetchInterval &&\n      (!query.currentRefetchInterval ||\n        // shorter interval should override previous one\n        config.refetchInterval < query.currentRefetchInterval)\n    ) {\n      query.currentRefetchInterval = config.refetchInterval\n      clearInterval(query.refetchIntervalId)\n      query.refetchIntervalId = setInterval(() => {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error)\n        }\n      }, config.refetchInterval)\n\n      return () => {\n        clearInterval(query.refetchIntervalId)\n        delete query.refetchIntervalId\n        delete query.currentRefetchInterval\n      }\n    }\n  }, [config.refetchInterval, config.refetchIntervalInBackground, refetch])\n\n  return {\n    ...query.state,\n    config,\n    query,\n    refetch,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  if (!queryKey) {\n    lastDataRef.current = undefined\n  }\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const query = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  let { data: latestData, status } = query\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success'\n  }\n\n  const paginatedQuery = {\n    ...query,\n    resolvedData,\n    latestData,\n    status,\n  }\n\n  handleSuspense(paginatedQuery)\n\n  return paginatedQuery\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = []\n    const pageVariables = [...queryInfoRef.current.query.pageVariables]\n    const rebuiltPageVariables = []\n\n    do {\n      const args = pageVariables.shift()\n\n      if (!data.length) {\n        // the first page query doesn't need to be rebuilt\n        data.push(await originalQueryFn(...args))\n        rebuiltPageVariables.push(args)\n      } else {\n        // get an up-to-date cursor based on the previous data set\n        const nextCursor = getGetFetchMore()(data[data.length - 1], data)\n\n        // break early if there's no next cursor\n        // otherwise we'll start from the beginning\n        // which will cause unwanted duplication\n        if (!nextCursor) {\n          break\n        }\n\n        const pageArgs = [\n          // remove the last argument (the previously saved cursor)\n          ...args.slice(0, -1),\n          nextCursor,\n        ]\n\n        data.push(await originalQueryFn(...pageArgs))\n        rebuiltPageVariables.push(pageArgs)\n      }\n    } while (pageVariables.length)\n\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    queryInfoRef.current.query.pageVariables = rebuiltPageVariables\n\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    refetch,\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [\n      [...queryInfo.query.queryKey, ...queryInfo.query.queryVariables],\n    ]\n  }\n\n  const fetchMore = React.useCallback(\n    (fetchMoreInfo = queryInfoRef.current.query.canFetchMore) =>\n      queryInfoRef.current.query.canFetchMore\n        ? refetch({\n            force: true,\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: true,\n                }))\n\n                const newArgs = [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables.push(newArgs)\n\n                const data = [\n                  ...queryInfoRef.current.data,\n                  await originalQueryFn(...newArgs),\n                ]\n\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  data[data.length - 1],\n                  data\n                )\n\n                return data\n              } finally {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: false,\n                }))\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn, refetch]\n  )\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n  }\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_async","f","args","i","arguments","length","Promise","resolve","apply","reject","_await","direct","_awaitIgnored","_empty","_continue","Symbol","iterator","asyncIterator","_do","body","test","awaitBody","shouldContinue","_resumeAfterBody","_resumeAfterTest","_invoke","_invokeIgnored","_catch","recover","_finallyRethrows","finalizer","_rethrow","thrown","statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","useGetLatest","obj","ref","React","useRef","current","useCallback","functionalUpdate","updater","old","stableStringifyReplacer","_","isObject","Object","assign","keys","sort","map","key","stableStringify","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","hasOwnProperty","queryKey","variables","queryFn","config","Error","useMountedCallback","mounted","handleSuspense","queryInfo","suspense","useErrorBoundary","status","setTimeout","query","wasSuspended","refetch","configContext","createContext","DEFAULTS","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchAllOnWindowFocus","refetchInterval","queryKeySerializerFn","defaultQueryKeySerializerFn","queryHash","parse","queryFnParamsFilter","d","throwOnError","onMutate","onSuccess","onError","onSettled","refetchOnMount","isDataEqual","deepEqual","valueOf","call","defaultConfigRef","useConfigContext","useContext","ReactQueryConfigProvider","children","configContextValue","newConfig","useMemo","useEffect","Provider","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","ReactQueryCacheProvider","cache","push","indexOf","splice","clear","actionInit","actionFailed","actionMarkStale","actionMarkGC","actionFetch","actionSuccess","actionError","actionSetState","listeners","queries","isFetching","notifyGlobalListeners","values","reduce","acc","forEach","subscribe","cb","findQueries","predicate","exact","filter","getQueries","getQuery","getQueryData","_cache$getQuery","data","removeQueries","foundQueries","clearTimeout","staleTimeout","cancelQueries","cancel","refetchQueries","force","all","fetch","err","_buildQuery","userQueryKey","queryVariables","options","reducer","queryReducer","defaultQueryReducer","noQueryHash","initialData","hasInitialData","isStale","manual","instances","type","initialStatus","dispatch","action","onStateUpdate","scheduleStaleTimeout","Infinity","scheduleGarbageCollection","cacheTimeout","markedForGarbageCollection","heal","cancelled","cancelPromises","promise","updateInstance","instance","found","find","id","instanceId","tryFetchData","failureCount","shouldContinueRetryOnFocus","delay","__queryFn","callbackInstances","unshift","suspenseInstance","setData","setState","makeQuery","prefetchQuery","res","wasPrefetched","setQueryData","canFetchMore","updatedAt","Date","now","removePreviousHandler","onWindowFocus","navigator","onLine","refetchOnWindowFocus","catch","setFocusHandler","useIsFetching","useState","handleFocus","_window","addEventListener","removeEventListener","getDefaultState","actionReset","actionLoading","actionResolve","actionReject","mutationReducer","useMutation","mutationFn","useReducer","getMutationFn","getConfig","latestMutationRef","mutate","mutationId","snapshotValue","isLatest","reset","useBaseQuery","queryRef","newQuery","rerender","getLatestConfig","rest","currentRefetchInterval","clearInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","paginatedQuery","useInfiniteQuery","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","pageVariables","rebuiltPageVariables","shift","nextCursor","pageArgs","slice","fetchMore","fetchMoreInfo","isFetchingMore","newArgs"],"mappings":"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"}